"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require("chai");
const helpers_1 = require("../../src/helpers");
const utils_1 = require("./utils");
const filter_param_parser_1 = require("../../src/parsing/filter-param-parser");
const noValidationFinalizeArgs = function (a, b, args) {
    return args;
};
const andOrOperators = {
    "and": { arity: Infinity, finalizeArgs: noValidationFinalizeArgs },
    "or": { arity: Infinity, finalizeArgs: noValidationFinalizeArgs }
};
const andOrProperOperators = {
    "and-list": {
        arity: Infinity,
        finalizeArgs(a, b, c) {
            if (!c.every(helpers_1.isFieldExpression)) {
                throw new Error("Arguments must be field expressions.");
            }
            return c;
        }
    },
    "or-list": {
        arity: Infinity,
        finalizeArgs(a, b, c) {
            if (!c.every(helpers_1.isFieldExpression)) {
                throw new Error("Arguments must be field expressions.");
            }
            return c;
        }
    }
};
const gteOperator = {
    "gte": { arity: 2, finalizeArgs: noValidationFinalizeArgs }
};
const gteExtendedOperator = {
    "gte": {
        arity: 1,
        finalizeArgs(a, b, args) {
            return ["custom args"];
        }
    }
};
const nowProperOperator = {
    "now": {
        arity: 0,
        finalizeArgs(a, b, args) {
            return args;
        }
    }
};
const eqProperOperator = {
    "eq": {
        arity: 2,
        finalizeArgs(a, b, args) {
            if (!helpers_1.isIdentifier(args[0])) {
                throw new Error("field reference required as first argument.");
            }
            return args;
        }
    }
};
describe("Filter param parsing", () => {
    it("should reject unknown operators", () => {
        expect(() => filter_param_parser_1.default(gteOperator, "(:now)")).to.throw(/"now" is not a recognized operator/);
        expect(() => filter_param_parser_1.default(gteOperator, "(gte,:fieldName,1)")).to.throw(/"fieldName"/);
    });
    it("should reject if the operator requires a different number of args", () => {
        expect(() => filter_param_parser_1.default(gteOperator, "(:gte,1)")).to.throw(/"gte" .+ exactly 2 arguments/);
        expect(() => filter_param_parser_1.default(nowProperOperator, "(:now,1)")).to.throw(/"now" .+ exactly 0 arguments/);
    });
    it("should validate arity of the *finalized* arg set", () => {
        expect(() => filter_param_parser_1.default(gteExtendedOperator, "(:gte,1)")).to.not.throw();
        expect(() => filter_param_parser_1.default(gteExtendedOperator, "(:gte,1,2,3)")).to.not.throw();
    });
    describe("finalizeFieldExpression/finalizeArgs", () => {
        it("should call it recursively", () => {
            expect(filter_param_parser_1.default(gteExtendedOperator, "(:gte,1000,fieldName,230)")).to.deep.equal([
                utils_1.FieldExpression("gte", ["custom args"])
            ]);
            expect(filter_param_parser_1.default(Object.assign({}, andOrOperators, gteExtendedOperator), "(:and,(:gte,1000,fieldName,230))")).to.deep.equal([
                utils_1.FieldExpression("and", [utils_1.FieldExpression("gte", ["custom args"])])
            ]);
            const missingFieldError = /field reference required/;
            expect(() => filter_param_parser_1.default(eqProperOperator, "(2,:eq,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(eqProperOperator, "((a,:eq,c),:eq,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(eqProperOperator, "(null,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(eqProperOperator, "([a,b],:eq,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(eqProperOperator, "(test,:eq,1)")).to.not.throw();
            const sutWithOps = filter_param_parser_1.default.bind(null, Object.assign({}, nowProperOperator, eqProperOperator, gteExtendedOperator, andOrOperators, andOrProperOperators));
            const invalidsToErrors = {
                "(:or,(field,:gte,2),(:test,fieldName,3))": /"test" .+ recognized operator/,
                "(:and,(:or,(:test,x,1)))": /"test" .+ recognized operator/,
                "(a,(:eq,field,2,2))": /"eq" .+ exactly 2 arguments/,
                "(a,(field,:eq,(:eq,field,0,0)))": /"eq" .+ exactly 2 arguments/,
                "(:and-list,true)": /arguments must be field expressions/i,
                "(:or-list,(field,:eq,2),(date,:gte,(:now)),(:and-list,test))": /arguments must be field expressions/i,
                "(:or-list,(:and-list,(:or-list,test)))": /arguments must be field expressions/i,
            };
            Object.keys(invalidsToErrors).forEach(k => {
                expect(() => sutWithOps(k)).to.throw(invalidsToErrors[k]);
            });
            expect(filter_param_parser_1.default(eqProperOperator, "(test,:eq,(a,:eq,c))")).to.deep.equal([
                utils_1.FieldExpression("eq", [
                    utils_1.Identifier("test"),
                    utils_1.FieldExpression("eq", [utils_1.Identifier("a"), utils_1.Identifier("c")])
                ])
            ]);
            expect(sutWithOps("(:and,(:or,(:and,(it,:eq,3)),(test,:gte,null)))"))
                .to.deep.equal([
                utils_1.FieldExpression("and", [
                    utils_1.FieldExpression("or", [
                        utils_1.FieldExpression("and", [
                            utils_1.FieldExpression("eq", [utils_1.Identifier("it"), 3])
                        ]),
                        utils_1.FieldExpression("gte", ["custom args"])
                    ])
                ])
            ]);
        });
    });
});
