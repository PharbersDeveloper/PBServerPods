"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require("chai");
const jsc = require("jsverify");
const filter_param_serializer_1 = require("../../src/serialization/filter-param-serializer");
const parser = require("../../src/parsing/parser");
const legalFilterToSerialization = {
    "(ab,:c,d)(3,:e,d)": true,
    "(:now)": true,
    "(:w,1)": true,
    "(:now,fieldName,[])": "(fieldName,:now,[])",
    "(:now,233,fieldName,(:now,1,2,3),[true])": true,
    "(fieldName,:eq,1)": "(fieldName,1)",
    "(fieldName,1)": true,
    "(1,fieldName)": true,
    "(ab,:c,d)": true,
    "(:ab,c)": true,
    "(true,:truedat,null)": true,
    "(:a-test)": true,
    "(2,:a-22d,3)": true,
    "(:a1d)": true,
    "(:a.test,2,-2,2.1,-2.1)": true,
    "(:test,.99,-.99,0.99,011.99,001.99)": "(:test,0.99,-0.99,0.99,11.99,1.99)",
    "(:a.22d)": true,
    "(:and,`test`,!test2!)": "(`test`,:and,`test2`)",
    "(:op,true,false,null)": true,
    "(:test,`%22J%26J%22%21%2C%20%27You%20know%20%28it%29%2C%20and%20%2A.`)": true,
    "(a,(:eq,field,2,2))": true,
    "(a,(field,:eq,[]))": "(a,(field,[]))",
    "(:and-list,true)": true,
    "(:or-list,(:and-list,(:or-list,test)))": true,
    "(:and,(:or,(:and,(it,:eq,3))))": "(:and,(:or,(:and,(it,3))))",
    "(:%C2%A9)": true,
    "(:op,%22J%26J%22%21%2C%20%27You%20know%20%28it%29%2C%20and%20%2A.)": true,
};
const Identifier = jsc.record({
    type: jsc.constant("Identifier"),
    value: jsc.nestring
});
const Atom = jsc.oneof([
    jsc.bool, jsc.string, jsc.number, jsc.constant(null), Identifier
]);
const { FieldExpression } = jsc.letrec((tie) => ({
    FieldExpressionEntry: jsc.bless({
        generator: jsc.generator.recursive(jsc.generator.small(jsc.oneof([Atom, tie("FieldExpression")]).generator), (gen) => jsc.generator.array(gen))
    }),
    FieldExpression: jsc.record({
        type: jsc.constant("FieldExpression"),
        operator: jsc.nestring,
        args: jsc.array(tie("FieldExpressionEntry"))
    })
}));
const Filter = jsc.nearray(FieldExpression);
describe("Filter Serialization", () => {
    it("should be the inverse of parsing (generated cases)", () => {
        jsc.assert(jsc.forall(Filter, (parsed) => {
            const serialized = filter_param_serializer_1.default(parsed);
            const reparsed = parser.parse(serialized, { startRule: "Filter" });
            expect(reparsed).to.deep.equal(parsed);
            return true;
        }));
    }).timeout(Infinity);
    it("should be the inverse of parsing (manual cases)", () => {
        Object.keys(legalFilterToSerialization).forEach(k => {
            const v = legalFilterToSerialization[k];
            const expected = v === true ? k : v;
            expect(filter_param_serializer_1.default(parser.parse(k, { startRule: "Filter" }))).to.equal(expected);
        });
    });
});
